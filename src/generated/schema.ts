// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "schema.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
/**
 * @generated from protobuf message Backup
 */
export interface Backup {
  /**
   * @ProtoNumber(1) val backupManga: List<BackupManga>
   *
   * @generated from protobuf field: repeated BackupManga backupManga = 1;
   */
  backupManga: BackupManga[]
  /**
   * @ProtoNumber(2) var backupCategories: List<BackupCategory> =
   *
   * @generated from protobuf field: repeated BackupCategory backupCategories = 2;
   */
  backupCategories: BackupCategory[]
  /**
   * @generated from protobuf field: repeated BrokenBackupSource backupBrokenSources = 100;
   */
  backupBrokenSources: BrokenBackupSource[]
  /**
   * @ProtoNumber(101) var backupSources: List<BackupSource> =
   *
   * @generated from protobuf field: repeated BackupSource backupSources = 101;
   */
  backupSources: BackupSource[]
  /**
   * @ProtoNumber(104) var backupPreferences: List<BackupPreference> =
   *
   * @generated from protobuf field: repeated BackupPreference backupPreferences = 104;
   */
  backupPreferences: BackupPreference[]
  /**
   * @ProtoNumber(105) var backupSourcePreferences: List<BackupSourcePreferences> =
   *
   * @generated from protobuf field: repeated BackupSourcePreferences backupSourcePreferences = 105;
   */
  backupSourcePreferences: BackupSourcePreferences[]
}
/**
 * @generated from protobuf message BackupCategory
 */
export interface BackupCategory {
  /**
   * @ProtoNumber(1) var name: String
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string
  /**
   * @ProtoNumber(2) var order: Long =
   *
   * @generated from protobuf field: optional int64 order = 2;
   */
  order?: bigint
  /**
   * @ProtoNumber(100) var flags: Long =
   *
   * @generated from protobuf field: optional int64 flags = 100;
   */
  flags?: bigint
}
/**
 * @generated from protobuf message BackupChapter
 */
export interface BackupChapter {
  /**
   * @ProtoNumber(1) var url: String
   *
   * @generated from protobuf field: string url = 1;
   */
  url: string
  /**
   * @ProtoNumber(2) var name: String
   *
   * @generated from protobuf field: string name = 2;
   */
  name: string
  /**
   * @ProtoNumber(3) var scanlator: String?
   *
   * @generated from protobuf field: optional string scanlator = 3;
   */
  scanlator?: string
  /**
   * @ProtoNumber(4) var read: Boolean =
   *
   * @generated from protobuf field: optional bool read = 4;
   */
  read?: boolean
  /**
   * @ProtoNumber(5) var bookmark: Boolean =
   *
   * @generated from protobuf field: optional bool bookmark = 5;
   */
  bookmark?: boolean
  /**
   * @ProtoNumber(6) var lastPageRead: Long =
   *
   * @generated from protobuf field: optional int64 lastPageRead = 6;
   */
  lastPageRead?: bigint
  /**
   * @ProtoNumber(7) var dateFetch: Long =
   *
   * @generated from protobuf field: optional int64 dateFetch = 7;
   */
  dateFetch?: bigint
  /**
   * @ProtoNumber(8) var dateUpload: Long =
   *
   * @generated from protobuf field: optional int64 dateUpload = 8;
   */
  dateUpload?: bigint
  /**
   * @ProtoNumber(9) var chapterNumber: Float =
   *
   * @generated from protobuf field: optional float chapterNumber = 9;
   */
  chapterNumber?: number
  /**
   * @ProtoNumber(10) var sourceOrder: Long =
   *
   * @generated from protobuf field: optional int64 sourceOrder = 10;
   */
  sourceOrder?: bigint
  /**
   * @ProtoNumber(11) var lastModifiedAt: Long =
   *
   * @generated from protobuf field: optional int64 lastModifiedAt = 11;
   */
  lastModifiedAt?: bigint
}
/**
 * @generated from protobuf message BackupHistory
 */
export interface BackupHistory {
  /**
   * @ProtoNumber(1) var url: String
   *
   * @generated from protobuf field: string url = 1;
   */
  url: string
  /**
   * @ProtoNumber(2) var lastRead: Long
   *
   * @generated from protobuf field: int64 lastRead = 2;
   */
  lastRead: bigint
  /**
   * @ProtoNumber(3) var readDuration: Long =
   *
   * @generated from protobuf field: optional int64 readDuration = 3;
   */
  readDuration?: bigint
}
/**
 * @generated from protobuf message BrokenBackupHistory
 */
export interface BrokenBackupHistory {
  /**
   * @generated from protobuf field: string url = 9999;
   */
  url: string
  /**
   * @generated from protobuf field: int64 lastRead = 1;
   */
  lastRead: bigint
  /**
   * @generated from protobuf field: int64 readDuration = 2;
   */
  readDuration: bigint
}
/**
 * @generated from protobuf message BackupManga
 */
export interface BackupManga {
  /**
   * @ProtoNumber(1) var source: Long
   *
   * @generated from protobuf field: int64 source = 1;
   */
  source: bigint
  /**
   * @ProtoNumber(2) var url: String
   *
   * @generated from protobuf field: string url = 2;
   */
  url: string
  /**
   * @ProtoNumber(3) var title: String =
   *
   * @generated from protobuf field: optional string title = 3;
   */
  title?: string
  /**
   * @ProtoNumber(4) var artist: String?
   *
   * @generated from protobuf field: optional string artist = 4;
   */
  artist?: string
  /**
   * @ProtoNumber(5) var author: String?
   *
   * @generated from protobuf field: optional string author = 5;
   */
  author?: string
  /**
   * @ProtoNumber(6) var description: String?
   *
   * @generated from protobuf field: optional string description = 6;
   */
  description?: string
  /**
   * @ProtoNumber(7) var genre: List<String> =
   *
   * @generated from protobuf field: repeated string genre = 7;
   */
  genre: string[]
  /**
   * @ProtoNumber(8) var status: Int =
   *
   * @generated from protobuf field: optional int32 status = 8;
   */
  status?: number
  /**
   * @ProtoNumber(9) var thumbnailUrl: String?
   *
   * @generated from protobuf field: optional string thumbnailUrl = 9;
   */
  thumbnailUrl?: string
  /**
   * @ProtoNumber(13) var dateAdded: Long =
   *
   * @generated from protobuf field: optional int64 dateAdded = 13;
   */
  dateAdded?: bigint
  /**
   * @ProtoNumber(14) var viewer: Int =
   *
   * @generated from protobuf field: optional int32 viewer = 14;
   */
  viewer?: number
  /**
   * @ProtoNumber(16) var chapters: List<BackupChapter> =
   *
   * @generated from protobuf field: repeated BackupChapter chapters = 16;
   */
  chapters: BackupChapter[]
  /**
   * @ProtoNumber(17) var categories: List<Long> =
   *
   * @generated from protobuf field: repeated int64 categories = 17;
   */
  categories: bigint[]
  /**
   * @ProtoNumber(18) var tracking: List<BackupTracking> =
   *
   * @generated from protobuf field: repeated BackupTracking tracking = 18;
   */
  tracking: BackupTracking[]
  /**
   * @ProtoNumber(100) var favorite: Boolean =
   *
   * @generated from protobuf field: optional bool favorite = 100;
   */
  favorite?: boolean
  /**
   * @ProtoNumber(101) var chapterFlags: Int =
   *
   * @generated from protobuf field: optional int32 chapterFlags = 101;
   */
  chapterFlags?: number
  /**
   * @ProtoNumber(103) var viewer_flags: Int?
   *
   * @generated from protobuf field: optional int32 viewer_flags = 103;
   */
  viewerFlags?: number
  /**
   * @ProtoNumber(104) var history: List<BackupHistory> =
   *
   * @generated from protobuf field: repeated BackupHistory history = 104;
   */
  history: BackupHistory[]
  /**
   * @ProtoNumber(105) var updateStrategy: UpdateStrategy =
   *
   * @generated from protobuf field: optional int32 updateStrategy = 105;
   */
  updateStrategy?: number
  /**
   * @ProtoNumber(106) var lastModifiedAt: Long =
   *
   * @generated from protobuf field: optional int64 lastModifiedAt = 106;
   */
  lastModifiedAt?: bigint
  /**
   * @ProtoNumber(107) var favoriteModifiedAt: Long?
   *
   * @generated from protobuf field: optional int64 favoriteModifiedAt = 107;
   */
  favoriteModifiedAt?: bigint
}
/**
 * @generated from protobuf message BackupPreference
 */
export interface BackupPreference {
  /**
   * @ProtoNumber(1) val key: String
   *
   * @generated from protobuf field: string key = 1;
   */
  key: string
  /**
   * @ProtoNumber(2) val value: PreferenceValue
   *
   * @generated from protobuf field: string value = 2;
   */
  value: string
}
/**
 * @generated from protobuf message BackupSourcePreferences
 */
export interface BackupSourcePreferences {
  /**
   * @ProtoNumber(1) val sourceKey: String
   *
   * @generated from protobuf field: string sourceKey = 1;
   */
  sourceKey: string
  /**
   * @ProtoNumber(2) val prefs: List<BackupPreference>
   *
   * @generated from protobuf field: repeated BackupPreference prefs = 2;
   */
  prefs: BackupPreference[]
}
/**
 * @generated from protobuf message BackupSource
 */
export interface BackupSource {
  /**
   * @ProtoNumber(1) var name: String =
   *
   * @generated from protobuf field: optional string name = 1;
   */
  name?: string
  /**
   * @ProtoNumber(2) var sourceId: Long
   *
   * @generated from protobuf field: int64 sourceId = 2;
   */
  sourceId: bigint
}
/**
 * @generated from protobuf message BrokenBackupSource
 */
export interface BrokenBackupSource {
  /**
   * @generated from protobuf field: string name = 9999;
   */
  name: string
  /**
   * @generated from protobuf field: int64 sourceId = 1;
   */
  sourceId: bigint
}
/**
 * @generated from protobuf message BackupTracking
 */
export interface BackupTracking {
  /**
   * @ProtoNumber(1) var syncId: Int
   *
   * @generated from protobuf field: int32 syncId = 1;
   */
  syncId: number
  /**
   * @ProtoNumber(2) var libraryId: Long
   *
   * @generated from protobuf field: int64 libraryId = 2;
   */
  libraryId: bigint
  /**
   * @ProtoNumber(3) var mediaIdInt: Int =
   *
   * @generated from protobuf field: optional int32 mediaIdInt = 3;
   */
  mediaIdInt?: number
  /**
   * @ProtoNumber(4) var trackingUrl: String =
   *
   * @generated from protobuf field: optional string trackingUrl = 4;
   */
  trackingUrl?: string
  /**
   * @ProtoNumber(5) var title: String =
   *
   * @generated from protobuf field: optional string title = 5;
   */
  title?: string
  /**
   * @ProtoNumber(6) var lastChapterRead: Float =
   *
   * @generated from protobuf field: optional float lastChapterRead = 6;
   */
  lastChapterRead?: number
  /**
   * @ProtoNumber(7) var totalChapters: Int =
   *
   * @generated from protobuf field: optional int32 totalChapters = 7;
   */
  totalChapters?: number
  /**
   * @ProtoNumber(8) var score: Float =
   *
   * @generated from protobuf field: optional float score = 8;
   */
  score?: number
  /**
   * @ProtoNumber(9) var status: Int =
   *
   * @generated from protobuf field: optional int32 status = 9;
   */
  status?: number
  /**
   * @ProtoNumber(10) var startedReadingDate: Long =
   *
   * @generated from protobuf field: optional int64 startedReadingDate = 10;
   */
  startedReadingDate?: bigint
  /**
   * @ProtoNumber(11) var finishedReadingDate: Long =
   *
   * @generated from protobuf field: optional int64 finishedReadingDate = 11;
   */
  finishedReadingDate?: bigint
  /**
   * @ProtoNumber(100) var mediaId: Long =
   *
   * @generated from protobuf field: optional int64 mediaId = 100;
   */
  mediaId?: bigint
}
// @generated message type with reflection information, may provide speed optimized methods
class Backup$Type extends MessageType<Backup> {
  constructor() {
    super('Backup', [
      {
        no: 1,
        name: 'backupManga',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupManga,
      },
      {
        no: 2,
        name: 'backupCategories',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupCategory,
      },
      {
        no: 100,
        name: 'backupBrokenSources',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BrokenBackupSource,
      },
      {
        no: 101,
        name: 'backupSources',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupSource,
      },
      {
        no: 104,
        name: 'backupPreferences',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupPreference,
      },
      {
        no: 105,
        name: 'backupSourcePreferences',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupSourcePreferences,
      },
    ])
  }

  create(value?: PartialMessage<Backup>): Backup {
    const message = {
      backupManga: [],
      backupCategories: [],
      backupBrokenSources: [],
      backupSources: [],
      backupPreferences: [],
      backupSourcePreferences: [],
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<Backup>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Backup,
  ): Backup {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated BackupManga backupManga */ 1:
          message.backupManga.push(
            BackupManga.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* repeated BackupCategory backupCategories */ 2:
          message.backupCategories.push(
            BackupCategory.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* repeated BrokenBackupSource backupBrokenSources */ 100:
          message.backupBrokenSources.push(
            BrokenBackupSource.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          )
          break
        case /* repeated BackupSource backupSources */ 101:
          message.backupSources.push(
            BackupSource.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* repeated BackupPreference backupPreferences */ 104:
          message.backupPreferences.push(
            BackupPreference.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          )
          break
        case /* repeated BackupSourcePreferences backupSourcePreferences */ 105:
          message.backupSourcePreferences.push(
            BackupSourcePreferences.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: Backup,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated BackupManga backupManga = 1; */
    for (let i = 0; i < message.backupManga.length; i++) {
      BackupManga.internalBinaryWrite(
        message.backupManga[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    /* repeated BackupCategory backupCategories = 2; */
    for (let i = 0; i < message.backupCategories.length; i++) {
      BackupCategory.internalBinaryWrite(
        message.backupCategories[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    /* repeated BrokenBackupSource backupBrokenSources = 100; */
    for (let i = 0; i < message.backupBrokenSources.length; i++) {
      BrokenBackupSource.internalBinaryWrite(
        message.backupBrokenSources[i],
        writer.tag(100, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    /* repeated BackupSource backupSources = 101; */
    for (let i = 0; i < message.backupSources.length; i++) {
      BackupSource.internalBinaryWrite(
        message.backupSources[i],
        writer.tag(101, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    /* repeated BackupPreference backupPreferences = 104; */
    for (let i = 0; i < message.backupPreferences.length; i++) {
      BackupPreference.internalBinaryWrite(
        message.backupPreferences[i],
        writer.tag(104, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    /* repeated BackupSourcePreferences backupSourcePreferences = 105; */
    for (let i = 0; i < message.backupSourcePreferences.length; i++) {
      BackupSourcePreferences.internalBinaryWrite(
        message.backupSourcePreferences[i],
        writer.tag(105, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message Backup
 */
export const Backup = new Backup$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BackupCategory$Type extends MessageType<BackupCategory> {
  constructor() {
    super('BackupCategory', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'order',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 100,
        name: 'flags',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }

  create(value?: PartialMessage<BackupCategory>): BackupCategory {
    const message = { name: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BackupCategory>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BackupCategory,
  ): BackupCategory {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* optional int64 order */ 2:
          message.order = reader.int64().toBigInt()
          break
        case /* optional int64 flags */ 100:
          message.flags = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BackupCategory,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.name)
    }
    /* optional int64 order = 2; */
    if (message.order !== undefined) {
      writer.tag(2, WireType.Varint).int64(message.order)
    }
    /* optional int64 flags = 100; */
    if (message.flags !== undefined) {
      writer.tag(100, WireType.Varint).int64(message.flags)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BackupCategory
 */
export const BackupCategory = new BackupCategory$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BackupChapter$Type extends MessageType<BackupChapter> {
  constructor() {
    super('BackupChapter', [
      { no: 1, name: 'url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'scanlator',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: 'read',
        kind: 'scalar',
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: 'bookmark',
        kind: 'scalar',
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 6,
        name: 'lastPageRead',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 7,
        name: 'dateFetch',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 8,
        name: 'dateUpload',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 9,
        name: 'chapterNumber',
        kind: 'scalar',
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 10,
        name: 'sourceOrder',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 11,
        name: 'lastModifiedAt',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }

  create(value?: PartialMessage<BackupChapter>): BackupChapter {
    const message = { url: '', name: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BackupChapter>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BackupChapter,
  ): BackupChapter {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string url */ 1:
          message.url = reader.string()
          break
        case /* string name */ 2:
          message.name = reader.string()
          break
        case /* optional string scanlator */ 3:
          message.scanlator = reader.string()
          break
        case /* optional bool read */ 4:
          message.read = reader.bool()
          break
        case /* optional bool bookmark */ 5:
          message.bookmark = reader.bool()
          break
        case /* optional int64 lastPageRead */ 6:
          message.lastPageRead = reader.int64().toBigInt()
          break
        case /* optional int64 dateFetch */ 7:
          message.dateFetch = reader.int64().toBigInt()
          break
        case /* optional int64 dateUpload */ 8:
          message.dateUpload = reader.int64().toBigInt()
          break
        case /* optional float chapterNumber */ 9:
          message.chapterNumber = reader.float()
          break
        case /* optional int64 sourceOrder */ 10:
          message.sourceOrder = reader.int64().toBigInt()
          break
        case /* optional int64 lastModifiedAt */ 11:
          message.lastModifiedAt = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BackupChapter,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string url = 1; */
    if (message.url !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.url)
    }
    /* string name = 2; */
    if (message.name !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.name)
    }
    /* optional string scanlator = 3; */
    if (message.scanlator !== undefined) {
      writer.tag(3, WireType.LengthDelimited).string(message.scanlator)
    }
    /* optional bool read = 4; */
    if (message.read !== undefined) {
      writer.tag(4, WireType.Varint).bool(message.read)
    }
    /* optional bool bookmark = 5; */
    if (message.bookmark !== undefined) {
      writer.tag(5, WireType.Varint).bool(message.bookmark)
    }
    /* optional int64 lastPageRead = 6; */
    if (message.lastPageRead !== undefined) {
      writer.tag(6, WireType.Varint).int64(message.lastPageRead)
    }
    /* optional int64 dateFetch = 7; */
    if (message.dateFetch !== undefined) {
      writer.tag(7, WireType.Varint).int64(message.dateFetch)
    }
    /* optional int64 dateUpload = 8; */
    if (message.dateUpload !== undefined) {
      writer.tag(8, WireType.Varint).int64(message.dateUpload)
    }
    /* optional float chapterNumber = 9; */
    if (message.chapterNumber !== undefined) {
      writer.tag(9, WireType.Bit32).float(message.chapterNumber)
    }
    /* optional int64 sourceOrder = 10; */
    if (message.sourceOrder !== undefined) {
      writer.tag(10, WireType.Varint).int64(message.sourceOrder)
    }
    /* optional int64 lastModifiedAt = 11; */
    if (message.lastModifiedAt !== undefined) {
      writer.tag(11, WireType.Varint).int64(message.lastModifiedAt)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BackupChapter
 */
export const BackupChapter = new BackupChapter$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BackupHistory$Type extends MessageType<BackupHistory> {
  constructor() {
    super('BackupHistory', [
      { no: 1, name: 'url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'lastRead',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: 'readDuration',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }

  create(value?: PartialMessage<BackupHistory>): BackupHistory {
    const message = { url: '', lastRead: 0n }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BackupHistory>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BackupHistory,
  ): BackupHistory {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string url */ 1:
          message.url = reader.string()
          break
        case /* int64 lastRead */ 2:
          message.lastRead = reader.int64().toBigInt()
          break
        case /* optional int64 readDuration */ 3:
          message.readDuration = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BackupHistory,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string url = 1; */
    if (message.url !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.url)
    }
    /* int64 lastRead = 2; */
    if (message.lastRead !== 0n) {
      writer.tag(2, WireType.Varint).int64(message.lastRead)
    }
    /* optional int64 readDuration = 3; */
    if (message.readDuration !== undefined) {
      writer.tag(3, WireType.Varint).int64(message.readDuration)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BackupHistory
 */
export const BackupHistory = new BackupHistory$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BrokenBackupHistory$Type extends MessageType<BrokenBackupHistory> {
  constructor() {
    super('BrokenBackupHistory', [
      { no: 9999, name: 'url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 1,
        name: 'lastRead',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: 'readDuration',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }

  create(value?: PartialMessage<BrokenBackupHistory>): BrokenBackupHistory {
    const message = { url: '', lastRead: 0n, readDuration: 0n }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BrokenBackupHistory>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BrokenBackupHistory,
  ): BrokenBackupHistory {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string url */ 9999:
          message.url = reader.string()
          break
        case /* int64 lastRead */ 1:
          message.lastRead = reader.int64().toBigInt()
          break
        case /* int64 readDuration */ 2:
          message.readDuration = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BrokenBackupHistory,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string url = 9999; */
    if (message.url !== '') {
      writer.tag(9999, WireType.LengthDelimited).string(message.url)
    }
    /* int64 lastRead = 1; */
    if (message.lastRead !== 0n) {
      writer.tag(1, WireType.Varint).int64(message.lastRead)
    }
    /* int64 readDuration = 2; */
    if (message.readDuration !== 0n) {
      writer.tag(2, WireType.Varint).int64(message.readDuration)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BrokenBackupHistory
 */
export const BrokenBackupHistory = new BrokenBackupHistory$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BackupManga$Type extends MessageType<BackupManga> {
  constructor() {
    super('BackupManga', [
      {
        no: 1,
        name: 'source',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: 'url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'title',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: 'artist',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: 'author',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: 'description',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 7,
        name: 'genre',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 8,
        name: 'status',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 9,
        name: 'thumbnailUrl',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 13,
        name: 'dateAdded',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 14,
        name: 'viewer',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 16,
        name: 'chapters',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupChapter,
      },
      {
        no: 17,
        name: 'categories',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 18,
        name: 'tracking',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupTracking,
      },
      {
        no: 100,
        name: 'favorite',
        kind: 'scalar',
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 101,
        name: 'chapterFlags',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 103,
        name: 'viewer_flags',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 104,
        name: 'history',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupHistory,
      },
      {
        no: 105,
        name: 'updateStrategy',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 106,
        name: 'lastModifiedAt',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 107,
        name: 'favoriteModifiedAt',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }

  create(value?: PartialMessage<BackupManga>): BackupManga {
    const message = {
      source: 0n,
      url: '',
      genre: [],
      chapters: [],
      categories: [],
      tracking: [],
      history: [],
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BackupManga>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BackupManga,
  ): BackupManga {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int64 source */ 1:
          message.source = reader.int64().toBigInt()
          break
        case /* string url */ 2:
          message.url = reader.string()
          break
        case /* optional string title */ 3:
          message.title = reader.string()
          break
        case /* optional string artist */ 4:
          message.artist = reader.string()
          break
        case /* optional string author */ 5:
          message.author = reader.string()
          break
        case /* optional string description */ 6:
          message.description = reader.string()
          break
        case /* repeated string genre */ 7:
          message.genre.push(reader.string())
          break
        case /* optional int32 status */ 8:
          message.status = reader.int32()
          break
        case /* optional string thumbnailUrl */ 9:
          message.thumbnailUrl = reader.string()
          break
        case /* optional int64 dateAdded */ 13:
          message.dateAdded = reader.int64().toBigInt()
          break
        case /* optional int32 viewer */ 14:
          message.viewer = reader.int32()
          break
        case /* repeated BackupChapter chapters */ 16:
          message.chapters.push(
            BackupChapter.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* repeated int64 categories */ 17:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.categories.push(reader.int64().toBigInt())
            }
          } else {
            message.categories.push(reader.int64().toBigInt())
          }
          break
        case /* repeated BackupTracking tracking */ 18:
          message.tracking.push(
            BackupTracking.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* optional bool favorite */ 100:
          message.favorite = reader.bool()
          break
        case /* optional int32 chapterFlags */ 101:
          message.chapterFlags = reader.int32()
          break
        case /* optional int32 viewer_flags */ 103:
          message.viewerFlags = reader.int32()
          break
        case /* repeated BackupHistory history */ 104:
          message.history.push(
            BackupHistory.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* optional int32 updateStrategy */ 105:
          message.updateStrategy = reader.int32()
          break
        case /* optional int64 lastModifiedAt */ 106:
          message.lastModifiedAt = reader.int64().toBigInt()
          break
        case /* optional int64 favoriteModifiedAt */ 107:
          message.favoriteModifiedAt = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BackupManga,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 source = 1; */
    if (message.source !== 0n) {
      writer.tag(1, WireType.Varint).int64(message.source)
    }
    /* string url = 2; */
    if (message.url !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.url)
    }
    /* optional string title = 3; */
    if (message.title !== undefined) {
      writer.tag(3, WireType.LengthDelimited).string(message.title)
    }
    /* optional string artist = 4; */
    if (message.artist !== undefined) {
      writer.tag(4, WireType.LengthDelimited).string(message.artist)
    }
    /* optional string author = 5; */
    if (message.author !== undefined) {
      writer.tag(5, WireType.LengthDelimited).string(message.author)
    }
    /* optional string description = 6; */
    if (message.description !== undefined) {
      writer.tag(6, WireType.LengthDelimited).string(message.description)
    }
    /* repeated string genre = 7; */
    for (let i = 0; i < message.genre.length; i++) {
      writer.tag(7, WireType.LengthDelimited).string(message.genre[i])
    }
    /* optional int32 status = 8; */
    if (message.status !== undefined) {
      writer.tag(8, WireType.Varint).int32(message.status)
    }
    /* optional string thumbnailUrl = 9; */
    if (message.thumbnailUrl !== undefined) {
      writer.tag(9, WireType.LengthDelimited).string(message.thumbnailUrl)
    }
    /* optional int64 dateAdded = 13; */
    if (message.dateAdded !== undefined) {
      writer.tag(13, WireType.Varint).int64(message.dateAdded)
    }
    /* optional int32 viewer = 14; */
    if (message.viewer !== undefined) {
      writer.tag(14, WireType.Varint).int32(message.viewer)
    }
    /* repeated BackupChapter chapters = 16; */
    for (let i = 0; i < message.chapters.length; i++) {
      BackupChapter.internalBinaryWrite(
        message.chapters[i],
        writer.tag(16, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    /* repeated int64 categories = 17; */
    for (let i = 0; i < message.categories.length; i++) {
      writer.tag(17, WireType.Varint).int64(message.categories[i])
    }
    /* repeated BackupTracking tracking = 18; */
    for (let i = 0; i < message.tracking.length; i++) {
      BackupTracking.internalBinaryWrite(
        message.tracking[i],
        writer.tag(18, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    /* optional bool favorite = 100; */
    if (message.favorite !== undefined) {
      writer.tag(100, WireType.Varint).bool(message.favorite)
    }
    /* optional int32 chapterFlags = 101; */
    if (message.chapterFlags !== undefined) {
      writer.tag(101, WireType.Varint).int32(message.chapterFlags)
    }
    /* optional int32 viewer_flags = 103; */
    if (message.viewerFlags !== undefined) {
      writer.tag(103, WireType.Varint).int32(message.viewerFlags)
    }
    /* repeated BackupHistory history = 104; */
    for (let i = 0; i < message.history.length; i++) {
      BackupHistory.internalBinaryWrite(
        message.history[i],
        writer.tag(104, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    /* optional int32 updateStrategy = 105; */
    if (message.updateStrategy !== undefined) {
      writer.tag(105, WireType.Varint).int32(message.updateStrategy)
    }
    /* optional int64 lastModifiedAt = 106; */
    if (message.lastModifiedAt !== undefined) {
      writer.tag(106, WireType.Varint).int64(message.lastModifiedAt)
    }
    /* optional int64 favoriteModifiedAt = 107; */
    if (message.favoriteModifiedAt !== undefined) {
      writer.tag(107, WireType.Varint).int64(message.favoriteModifiedAt)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BackupManga
 */
export const BackupManga = new BackupManga$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BackupPreference$Type extends MessageType<BackupPreference> {
  constructor() {
    super('BackupPreference', [
      { no: 1, name: 'key', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }

  create(value?: PartialMessage<BackupPreference>): BackupPreference {
    const message = { key: '', value: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BackupPreference>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BackupPreference,
  ): BackupPreference {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string()
          break
        case /* string value */ 2:
          message.value = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BackupPreference,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.key)
    }
    /* string value = 2; */
    if (message.value !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.value)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BackupPreference
 */
export const BackupPreference = new BackupPreference$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BackupSourcePreferences$Type extends MessageType<BackupSourcePreferences> {
  constructor() {
    super('BackupSourcePreferences', [
      { no: 1, name: 'sourceKey', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'prefs',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BackupPreference,
      },
    ])
  }

  create(
    value?: PartialMessage<BackupSourcePreferences>,
  ): BackupSourcePreferences {
    const message = { sourceKey: '', prefs: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BackupSourcePreferences>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BackupSourcePreferences,
  ): BackupSourcePreferences {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string sourceKey */ 1:
          message.sourceKey = reader.string()
          break
        case /* repeated BackupPreference prefs */ 2:
          message.prefs.push(
            BackupPreference.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BackupSourcePreferences,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string sourceKey = 1; */
    if (message.sourceKey !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.sourceKey)
    }
    /* repeated BackupPreference prefs = 2; */
    for (let i = 0; i < message.prefs.length; i++) {
      BackupPreference.internalBinaryWrite(
        message.prefs[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BackupSourcePreferences
 */
export const BackupSourcePreferences = new BackupSourcePreferences$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BackupSource$Type extends MessageType<BackupSource> {
  constructor() {
    super('BackupSource', [
      {
        no: 1,
        name: 'name',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: 'sourceId',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }

  create(value?: PartialMessage<BackupSource>): BackupSource {
    const message = { sourceId: 0n }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BackupSource>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BackupSource,
  ): BackupSource {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string name */ 1:
          message.name = reader.string()
          break
        case /* int64 sourceId */ 2:
          message.sourceId = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BackupSource,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string name = 1; */
    if (message.name !== undefined) {
      writer.tag(1, WireType.LengthDelimited).string(message.name)
    }
    /* int64 sourceId = 2; */
    if (message.sourceId !== 0n) {
      writer.tag(2, WireType.Varint).int64(message.sourceId)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BackupSource
 */
export const BackupSource = new BackupSource$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BrokenBackupSource$Type extends MessageType<BrokenBackupSource> {
  constructor() {
    super('BrokenBackupSource', [
      { no: 9999, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 1,
        name: 'sourceId',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }

  create(value?: PartialMessage<BrokenBackupSource>): BrokenBackupSource {
    const message = { name: '', sourceId: 0n }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BrokenBackupSource>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BrokenBackupSource,
  ): BrokenBackupSource {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 9999:
          message.name = reader.string()
          break
        case /* int64 sourceId */ 1:
          message.sourceId = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BrokenBackupSource,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 9999; */
    if (message.name !== '') {
      writer.tag(9999, WireType.LengthDelimited).string(message.name)
    }
    /* int64 sourceId = 1; */
    if (message.sourceId !== 0n) {
      writer.tag(1, WireType.Varint).int64(message.sourceId)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BrokenBackupSource
 */
export const BrokenBackupSource = new BrokenBackupSource$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BackupTracking$Type extends MessageType<BackupTracking> {
  constructor() {
    super('BackupTracking', [
      { no: 1, name: 'syncId', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      {
        no: 2,
        name: 'libraryId',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: 'mediaIdInt',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: 'trackingUrl',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: 'title',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: 'lastChapterRead',
        kind: 'scalar',
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 7,
        name: 'totalChapters',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 8,
        name: 'score',
        kind: 'scalar',
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 9,
        name: 'status',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 10,
        name: 'startedReadingDate',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 11,
        name: 'finishedReadingDate',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 100,
        name: 'mediaId',
        kind: 'scalar',
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }

  create(value?: PartialMessage<BackupTracking>): BackupTracking {
    const message = { syncId: 0, libraryId: 0n }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined) {
      reflectionMergePartial<BackupTracking>(this, message, value)
    }
    return message
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BackupTracking,
  ): BackupTracking {
    const message = target ?? this.create()
    const end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 syncId */ 1:
          message.syncId = reader.int32()
          break
        case /* int64 libraryId */ 2:
          message.libraryId = reader.int64().toBigInt()
          break
        case /* optional int32 mediaIdInt */ 3:
          message.mediaIdInt = reader.int32()
          break
        case /* optional string trackingUrl */ 4:
          message.trackingUrl = reader.string()
          break
        case /* optional string title */ 5:
          message.title = reader.string()
          break
        case /* optional float lastChapterRead */ 6:
          message.lastChapterRead = reader.float()
          break
        case /* optional int32 totalChapters */ 7:
          message.totalChapters = reader.int32()
          break
        case /* optional float score */ 8:
          message.score = reader.float()
          break
        case /* optional int32 status */ 9:
          message.status = reader.int32()
          break
        case /* optional int64 startedReadingDate */ 10:
          message.startedReadingDate = reader.int64().toBigInt()
          break
        case /* optional int64 finishedReadingDate */ 11:
          message.finishedReadingDate = reader.int64().toBigInt()
          break
        case /* optional int64 mediaId */ 100:
          message.mediaId = reader.int64().toBigInt()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          }
          const d = reader.skip(wireType)
          if (u !== false) {
            ;(u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
          }
      }
    }
    return message
  }

  internalBinaryWrite(
    message: BackupTracking,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 syncId = 1; */
    if (message.syncId !== 0) {
      writer.tag(1, WireType.Varint).int32(message.syncId)
    }
    /* int64 libraryId = 2; */
    if (message.libraryId !== 0n) {
      writer.tag(2, WireType.Varint).int64(message.libraryId)
    }
    /* optional int32 mediaIdInt = 3; */
    if (message.mediaIdInt !== undefined) {
      writer.tag(3, WireType.Varint).int32(message.mediaIdInt)
    }
    /* optional string trackingUrl = 4; */
    if (message.trackingUrl !== undefined) {
      writer.tag(4, WireType.LengthDelimited).string(message.trackingUrl)
    }
    /* optional string title = 5; */
    if (message.title !== undefined) {
      writer.tag(5, WireType.LengthDelimited).string(message.title)
    }
    /* optional float lastChapterRead = 6; */
    if (message.lastChapterRead !== undefined) {
      writer.tag(6, WireType.Bit32).float(message.lastChapterRead)
    }
    /* optional int32 totalChapters = 7; */
    if (message.totalChapters !== undefined) {
      writer.tag(7, WireType.Varint).int32(message.totalChapters)
    }
    /* optional float score = 8; */
    if (message.score !== undefined) {
      writer.tag(8, WireType.Bit32).float(message.score)
    }
    /* optional int32 status = 9; */
    if (message.status !== undefined) {
      writer.tag(9, WireType.Varint).int32(message.status)
    }
    /* optional int64 startedReadingDate = 10; */
    if (message.startedReadingDate !== undefined) {
      writer.tag(10, WireType.Varint).int64(message.startedReadingDate)
    }
    /* optional int64 finishedReadingDate = 11; */
    if (message.finishedReadingDate !== undefined) {
      writer.tag(11, WireType.Varint).int64(message.finishedReadingDate)
    }
    /* optional int64 mediaId = 100; */
    if (message.mediaId !== undefined) {
      writer.tag(100, WireType.Varint).int64(message.mediaId)
    }
    const u = options.writeUnknownFields
    if (u !== false) {
      ;(u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    }
    return writer
  }
}
/**
 * @generated MessageType for protobuf message BackupTracking
 */
export const BackupTracking = new BackupTracking$Type()
